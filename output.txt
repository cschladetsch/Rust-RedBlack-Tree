   Compiling rbtree v0.1.0 (C:\Users\chris\local\repos\Rust\rbtree)
error[E0308]: mismatched types
   --> src\lib.rs:116:53
    |
116 |                 node.right = Self::remove_recursive(&mut node.right, successor.value);
    |                              ---------------------- ^^^^^^^^^^^^^^^ expected `&mut Box<Node<T>>`, found `&mut Option<Box<Node<T>>>`
    |                              |
    |                              arguments to this function are incorrect
    |
    = note: expected mutable reference `&mut Box<Node<T>>`
               found mutable reference `&mut Option<Box<Node<T>>>`
note: associated function defined here
   --> src\lib.rs:92:12
    |
92  |         fn remove_recursive(node: &mut Box<Node<T>>, value: T) -> Option<Box<Node<T>>> {
    |            ^^^^^^^^^^^^^^^^ -----------------------

error[E0425]: cannot find function `fix_deletion` in this scope
   --> src\lib.rs:119:13
    |
119 |             fix_deletion(node);
    |             ^^^^^^^^^^^^ not found in this scope
    |
help: consider using the associated function
    |
119 |             Self::fix_deletion(node);
    |             ++++++

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src\lib.rs:158:52
    |
158 |                     if let Some(ref mut sibling) = Self::sibling(node) {
    |                                                    ^^^^^^^^^^^^^ ---- an argument of type `&RedBlackTree<T>` is missing
    |
note: method defined here
   --> src\lib.rs:237:8
    |
237 |     fn sibling(&self, node: &Option<Box<Node<T>>>) -> Option<&mut Box<Node<T>>> {
    |        ^^^^^^^ -----  ---------------------------
help: provide the argument
    |
158 |                     if let Some(ref mut sibling) = Self::sibling(/* &RedBlackTree<T> */, node) {
    |                                                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src\lib.rs:162:52
    |
162 | ...                   Self::fix_deletion(Self::parent(node));
    |                                          ^^^^^^^^^^^^ ---- an argument of type `&RedBlackTree<T>` is missing
    |
note: method defined here
   --> src\lib.rs:205:8
    |
205 |     fn parent(&self, node: &Option<Box<Node<T>>>) -> Option<&mut Box<Node<T>>> {
    |        ^^^^^^ -----  ---------------------------
help: provide the argument
    |
162 |                                 Self::fix_deletion(Self::parent(/* &RedBlackTree<T> */, node));
    |                                                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error[E0308]: mismatched types
   --> src\lib.rs:162:52
    |
162 | ...                   Self::fix_deletion(Self::parent(node));
    |                       ------------------ ^^^^^^^^^^^^^^^^^^ expected `&mut Option<Box<Node<T>>>`, found `Option<&mut Box<Node<T>>>`
    |                       |
    |                       arguments to this function are incorrect
    |
    = note: expected mutable reference `&mut Option<Box<Node<T>>>`
                            found enum `Option<&mut Box<Node<T>>>`
note: associated function defined here
   --> src\lib.rs:137:12
    |
137 |         fn fix_deletion(node: &mut Option<Box<Node<T>>>) {
    |            ^^^^^^^^^^^^ -------------------------------

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src\lib.rs:192:19
    |
192 |             match Self::parent(node) {
    |                   ^^^^^^^^^^^^ ---- an argument of type `&RedBlackTree<T>` is missing
    |
note: method defined here
   --> src\lib.rs:205:8
    |
205 |     fn parent(&self, node: &Option<Box<Node<T>>>) -> Option<&mut Box<Node<T>>> {
    |        ^^^^^^ -----  ---------------------------
help: provide the argument
    |
192 |             match Self::parent(/* &RedBlackTree<T> */, node) {
    |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error[E0369]: binary operation `==` cannot be applied to type `Option<Box<Node<T>>>`
   --> src\lib.rs:193:49
    |
193 |                 Some(ref parent) => parent.left == *node,
    |                                     ----------- ^^ ----- Option<Box<Node<T>>>
    |                                     |
    |                                     Option<Box<Node<T>>>
    |
note: an implementation of `PartialEq` might be missing for `Node<T>`
   --> src\lib.rs:11:1
    |
11  | struct Node<T> {
    | ^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `Node<T>` with `#[derive(PartialEq)]`
    |
11  + #[derive(PartialEq)]
12  | struct Node<T> {
    |
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
    |
23  | impl<T: Clone + Ord> RedBlackTree<T> where Node<T>: PartialEq {
    |                                      ++++++++++++++++++++++++

error[E0061]: this function takes 2 arguments but 1 argument was supplied
   --> src\lib.rs:199:19
    |
199 |             match Self::parent(node) {
    |                   ^^^^^^^^^^^^ ---- an argument of type `&RedBlackTree<T>` is missing
    |
note: method defined here
   --> src\lib.rs:205:8
    |
205 |     fn parent(&self, node: &Option<Box<Node<T>>>) -> Option<&mut Box<Node<T>>> {
    |        ^^^^^^ -----  ---------------------------
help: provide the argument
    |
199 |             match Self::parent(/* &RedBlackTree<T> */, node) {
    |                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

error[E0369]: binary operation `==` cannot be applied to type `Option<Box<Node<T>>>`
   --> src\lib.rs:200:50
    |
200 |                 Some(ref parent) => parent.right == *node,
    |                                     ------------ ^^ ----- Option<Box<Node<T>>>
    |                                     |
    |                                     Option<Box<Node<T>>>
    |
note: an implementation of `PartialEq` might be missing for `Node<T>`
   --> src\lib.rs:11:1
    |
11  | struct Node<T> {
    | ^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `Node<T>` with `#[derive(PartialEq)]`
    |
11  + #[derive(PartialEq)]
12  | struct Node<T> {
    |
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
    |
23  | impl<T: Clone + Ord> RedBlackTree<T> where Node<T>: PartialEq {
    |                                      ++++++++++++++++++++++++

error[E0308]: mismatched types
   --> src\lib.rs:207:35
    |
207 |             self.parent_recursive(root, node)
    |                  ---------------- ^^^^ types differ in mutability
    |                  |
    |                  arguments to this method are incorrect
    |
    = note: expected mutable reference `&mut Box<Node<T>>`
                       found reference `&Box<Node<T>>`
note: method defined here
   --> src\lib.rs:213:8
    |
213 |     fn parent_recursive<'a>(
    |        ^^^^^^^^^^^^^^^^
214 |         &'a mut self,
215 |         current: &'a mut Box<Node<T>>,
    |         -----------------------------

error[E0369]: binary operation `==` cannot be applied to type `Option<Box<Node<T>>>`
   --> src\lib.rs:218:25
    |
218 |         if current.left == *target || current.right == *target {
    |            ------------ ^^ ------- Option<Box<Node<T>>>
    |            |
    |            Option<Box<Node<T>>>
    |
note: an implementation of `PartialEq` might be missing for `Node<T>`
   --> src\lib.rs:11:1
    |
11  | struct Node<T> {
    | ^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `Node<T>` with `#[derive(PartialEq)]`
    |
11  + #[derive(PartialEq)]
12  | struct Node<T> {
    |
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
    |
23  | impl<T: Clone + Ord> RedBlackTree<T> where Node<T>: PartialEq {
    |                                      ++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `Option<Box<Node<T>>>`
   --> src\lib.rs:218:53
    |
218 |         if current.left == *target || current.right == *target {
    |                                       ------------- ^^ ------- Option<Box<Node<T>>>
    |                                       |
    |                                       Option<Box<Node<T>>>
    |
note: an implementation of `PartialEq` might be missing for `Node<T>`
   --> src\lib.rs:11:1
    |
11  | struct Node<T> {
    | ^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `Node<T>` with `#[derive(PartialEq)]`
    |
11  + #[derive(PartialEq)]
12  | struct Node<T> {
    |
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
    |
23  | impl<T: Clone + Ord> RedBlackTree<T> where Node<T>: PartialEq {
    |                                      ++++++++++++++++++++++++

error[E0369]: binary operation `==` cannot be applied to type `Option<Box<Node<T>>>`
   --> src\lib.rs:239:22
    |
239 |             if *node == parent.left {
    |                ----- ^^ ----------- Option<Box<Node<T>>>
    |                |
    |                Option<Box<Node<T>>>
    |
note: an implementation of `PartialEq` might be missing for `Node<T>`
   --> src\lib.rs:11:1
    |
11  | struct Node<T> {
    | ^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `Node<T>` with `#[derive(PartialEq)]`
    |
11  + #[derive(PartialEq)]
12  | struct Node<T> {
    |
help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement
    |
23  | impl<T: Clone + Ord> RedBlackTree<T> where Node<T>: PartialEq {
    |                                      ++++++++++++++++++++++++

error[E0308]: mismatched types
   --> src\lib.rs:253:34
    |
253 |             std::mem::swap(node, &mut right);
    |             --------------       ^^^^^^^^^^ expected `&mut Option<Box<Node<T>>>`, found `&mut Box<Node<T>>`
    |             |
    |             arguments to this function are incorrect
    |
    = note: expected mutable reference `&mut Option<Box<Node<T>>>`
               found mutable reference `&mut Box<Node<T>>`
note: function defined here
   --> /rustc/db7ff98a72f3e742b641f9cb16d0e8c285e87e9b\library\core\src\mem\mod.rs:726:14

error[E0308]: mismatched types
   --> src\lib.rs:255:21
    |
255 |             *node = right;
    |             -----   ^^^^^ expected `Option<Box<Node<T>>>`, found `Box<Node<T>>`
    |             |
    |             expected due to the type of this binding
    |
    = note: expected enum `Option<Box<_>>`
             found struct `Box<_>`
help: try wrapping the expression in `Some`
    |
255 |             *node = Some(right);
    |                     +++++     +

error[E0308]: mismatched types
   --> src\lib.rs:263:34
    |
263 |             std::mem::swap(node, &mut left);
    |             --------------       ^^^^^^^^^ expected `&mut Option<Box<Node<T>>>`, found `&mut Box<Node<T>>`
    |             |
    |             arguments to this function are incorrect
    |
    = note: expected mutable reference `&mut Option<Box<Node<T>>>`
               found mutable reference `&mut Box<Node<T>>`
note: function defined here
   --> /rustc/db7ff98a72f3e742b641f9cb16d0e8c285e87e9b\library\core\src\mem\mod.rs:726:14

error[E0308]: mismatched types
   --> src\lib.rs:265:21
    |
265 |             *node = left;
    |             -----   ^^^^ expected `Option<Box<Node<T>>>`, found `Box<Node<T>>`
    |             |
    |             expected due to the type of this binding
    |
    = note: expected enum `Option<Box<_>>`
             found struct `Box<_>`
help: try wrapping the expression in `Some`
    |
265 |             *node = Some(left);
    |                     +++++    +

Some errors have detailed explanations: E0061, E0308, E0369, E0425.
For more information about an error, try `rustc --explain E0061`.
error: could not compile `rbtree` (lib) due to 17 previous errors
warning: build failed, waiting for other jobs to finish...
error: could not compile `rbtree` (lib test) due to 17 previous errors
